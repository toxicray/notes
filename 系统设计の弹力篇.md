​                                      

# 				系统设计の弹力篇



### 一、隔离

​		隔离其实就是微服务的一个本质

​		说明,比如我们一艘船的船舱设计,如何避免我们的一艘船就因为一个小的漏洞就来导致沉船事故的发生呢

​		船舱就可以来进行隔离设计,这样系统的局部问题就不会导致整个系统的崩溃,从而提升了我们系统的可用性

​			

​		这种对应到我们的系统中的话其实就是对应着多租户的概念,其中就会有三种常见的情况:

1. 完全隔离的设计, 各自有各自的独立设计,独立的数据,独立的服务
2. 独立的数据分区,共享的服务
3. 共享的服务和共享的数据



这里面也有对应的利弊:

资源共享度:    低  -->  高

实现复杂度:    低  -->  高

隔离度: 高  -->  低

占用成本度:  高  -->  低



完全独立的这种方案设计也就是当前比较流行的java微服务设计, 针对成本高这个缺点:

1. 初期可以考虑折中的方案,但是设计上注意规划,为后续留下分离的空间
2. 当前的虚拟化技术已经非常的成熟, 我们可以使用共享的物理资源来进行服务的隔离, 也是能降低成本的
3. 设计上也需要考虑隔离的粒度大小, 其实这也是对应着系统里面的不同隔离度
4. 隔离的设计里面需要面临很多的问题, 需要考虑高可用、重试、异步、流控,熔断等服务治理的问题
5. 分布式设计会带来运维的复杂度,当前的自动化运维相关技术给我们提供了极大的便利,降低运维成本
6. 我们会需要一个很好的服务监控平台,这种在当前的解决方案也是有的



### 二、异步通讯

我们在服务间的通讯分为两种情况,同步调用和异步调用

同步调用的问题是

1. 调用的时间会受限于最慢的服务

2. 调用方会有极大的资源开销,尤其是面临着慢接口的时候

3. 故障容易累计像多米诺骨牌一样蔓延,导致系统雪崩

   

   

   ##### 异步通讯的三种方式:

   ###### 请求响应式

   被调用方直接返回一个结果,如已收到,正在处理,这种返回结果也有两种处理方式:

   1,发送方去不断的轮训这个结果, 干完了么

   2,发送方发送请求的时候直接提供回调的信息,处理完之后被调用方完成回调逻辑即可

   这种场景下其实也还是会有轻度的耦合

   ###### 订阅式

   实现调用方的和被调用方的完全解耦,其中依赖broker'来进行数据承载,那么对broker就会有如下的要求:

   1. 必须得是满足高可用

   2. 必须得是高性能,可以轻易的进行扩展的

   3. 需要能保证数据的安全,也就是数据的持久化需要做好

      在高性能和数据的安全性之间, 这个在计算机的领域里面往往会是矛盾的,我们关注的问题点会一直放在矛盾上,所谓的解决问题本质上基本都是为了解决矛盾

   

   ###### 事件驱动

   比如说A完后了某个事件之后会发送一个事件,那么B就可以根据这个事件来进行下一步

   感觉和java的观察者设计模式很像,也会带来很多的问题

   1. 业务的流程可读性变得极差,不好管理
   2. 各个动作的顺序执行容易出bug

   

   异步设计的重点:

   高可用

   

   

   

   ## 三、幂等

   在业务上的理解,多次请求和一次请求的结果是一样的,数学上的理解方式

   ```
   f(x)= f(f(x))
   ```

   

   

   

   

   

   

   

